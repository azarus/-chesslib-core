import { PawnPiece } from "./Pieces/Pawn";
import { BishopPiece } from "./Pieces/Bishop";
import { KnightPiece } from "./Pieces/Knight";
import { RookPiece } from "./Pieces/Rook";
import { QueenPiece } from "./Pieces/Queen";
import { KingPiece } from "./Pieces/King";
import { ChessEventEmitter } from "./Utils";
export declare class Chessboard {
    static SIDE: string;
    static RANKS: string[];
    static PIECES: {
        P: typeof PawnPiece;
        B: typeof BishopPiece;
        N: typeof KnightPiece;
        R: typeof RookPiece;
        Q: typeof QueenPiece;
        K: typeof KingPiece;
    };
    boardSize: {
        x: number;
        y: number;
    };
    history: any[];
    squares: any[];
    onPromote: ChessEventEmitter;
    onCastled: ChessEventEmitter;
    constructor(sizeX?: number, sizeY?: number);
    static fromPosition(position: any): Chessboard;
    clone(): Chessboard;
    reset(): void;
    forEach(callback: any): void;
    forEachPiece(callback: any): void;
    findPieces(pieceType?: any, color?: any): any[];
    map(callback: any): any[];
    loadPositions(positions: any): boolean;
    savePositions(): any[];
    setBoard(board: any): void;
    getBoard(): {};
    getSquare(x: any, y: any): any;
    setSquare(square: any, type: any, color: any): any;
    createPiece(type: any, color: any, square: any): any;
    setPiece(square: any, piece: any): boolean;
    clearSquare(square: any): void;
    isValidMoveFEN(from: any, to: any): boolean;
    isValidMove(from: any, to: any): boolean;
    doMove(move: any): void;
    doMoveFEN(move: any): void;
    move(from: any, to: any, simulatedMove?: boolean): any;
    addHistory(piece: any, data: any): void;
    undo(): any;
    moveFEN(from: any, to: any, simulatedMove?: boolean): any;
    tryMove(from: any, to: any, simulatedMove?: boolean): any;
    tryMoveFEN(from: any, to: any, simulatedMove?: boolean): any;
    getAllowedMovesOf(piece: any): any;
    getMovesOf(piece: any): any;
    getMovesAtFEN(fen: any): any;
    getFENMovesatFEN(fen: any): any;
    getMoves(color?: any): any[];
    getMovesFEN(color?: any): any[];
    PositionToFEN(x: any, y: any): string;
    FENtoPosition(fen: any): {
        x: number;
        y: number;
    };
    FENToSquare(fen: any): any;
    SquareToFEN(square: any): string;
    charIndex(index: any): string;
    indexOfChar(char: any): number;
    clearDebug(): void;
    debugSquare(square: any, debugColor: any): void;
    debugFEN(fen: any, debugColor: any): void;
    debugMoves(fen: any, debugColor: any): boolean;
}
